import streamlit as st
import plotly.express as px
import pandas as pd
import os
import warnings

#Python command used to suppress or ignore warning messages generated by various Python libraries or modules
warnings.filterwarnings('ignore')

#Setting page title and icon 
st.set_page_config(page_title="Superstore", page_icon=":bar_chart:",layout="wide")
st.title(" :bar_chart: Sample SuperStore EDA")
st.markdown('<style>div.block-container{padding-top:1rem;}</style>',unsafe_allow_html=True)

#Create a file upload widget that allows users to upload a file, in this case, an Excel file with a .xls extension; assign file to fl
fl = st.file_uploader(":file_folder: Upload a file",type=(["xls"]))

#If file was uploaded by user
if fl is not None:
    #Extracts the file name of the uploaded file and assigns the name to filename
    filename = fl.name
    #Displays the filename on the Streamlit app's interface
    st.write(filename)
    #Read an Excel file and store its contents in a Pandas DataFrame
    df = pd.read_excel(filename)
#If no file was uploaded 
else:
    #Change the current working directory to the specified directory
    os.chdir(r"C:\Users\m1239\OneDrive\Documents\PythonProjects\Interactive_Dashboard")
    #Read an Excel file and store its contents in a Pandas DataFrame
    df = pd.read_excel("Superstore.xls")

#Creating two columns 
col1, col2 = st.columns((2))
#Convert column "Order Date" in a Pandas DataFrame df to a datetime data type using the pd.to_datetime() function.
#The "Order Date" column in DataFrame will contain datetime objects, which will allow us to perform various date and time operations on that column
df["Order Date"] = pd.to_datetime(df["Order Date"])

# Getting the min and max date 
startDate = pd.to_datetime(df["Order Date"]).min()
endDate = pd.to_datetime(df["Order Date"]).max()

#Using date_input widget to create a date input field for the "Start Date" and putting that in column 1  
with col1:
    date1 = pd.to_datetime(st.date_input("Start Date", startDate))
#Using date_input widget to create a date input field for the "End Date" and putting that in column 2 
with col2:
    date2 = pd.to_datetime(st.date_input("End Date", endDate))

#Assign to df only the rows where the "Order Date" falls within the specified date range
#Any modifications made to this filtered DataFrame will not affect the original df.
df = df[(df["Order Date"] >= date1) & (df["Order Date"] <= date2)].copy()

#Create a header in the sidebar 
st.sidebar.header("Choose your filter: ")

#Display multiselect widget in the sidebar with the label "Pick your Region" and a list of unique region options from your DataFrame
#Users can then select one or more regions that they want to filter the data by.
region = st.sidebar.multiselect("Pick your Region", df["Region"].unique())

#Based on whether the user has selected regions or not, you will have two different DataFrames:
    #df2 containing all data if no regions are selected
    #Or df2 containing only the rows related to the selected regions if one or more regions are chosen
if not region:
    df2 = df.copy()
else:
    df2 = df[df["Region"].isin(region)]

#Display multiselect widget in the sidebar with the label "Pick the State" and a list of unique state options from your DataFrame
#The states shown are dependent on the region(s) that the user selected 
#Users can then select one or more states that they want to filter the data by
state = st.sidebar.multiselect("Pick the State", df2["State"].unique())

#Based on whether the user has selected states or not, you will have two different DataFrames:
    #df3 containing all data if no states are selected
    #Or df3 containing only the rows related to the selected states if one or more states are chosen 
if not state:
    df3 = df2.copy()
else:
    df3 = df2[df2["State"].isin(state)]

#Display multiselect widget in the sidebar with the label "Pick the City" and a list of unique city options from your DataFrame
#The cities shown are dependent on the state(s) that the user selected 
#Users can then select one or more cities that they want to filter the data by
city = st.sidebar.multiselect("Pick the City",df3["City"].unique())

#Filter DataFrame df based on user-selected filters for "Region," "State," and "City"
#Depending on what user selected, filtered_df will either contain the entire dataset (df) or a subset of it
if not region and not state and not city:
    filtered_df = df
elif not state and not city:
    filtered_df = df[df["Region"].isin(region)]
elif not region and not city:
    filtered_df = df[df["State"].isin(state)]
elif state and city:
    filtered_df = df3[df["State"].isin(state) & df3["City"].isin(city)]
elif region and city:
    filtered_df = df3[df["Region"].isin(region) & df3["City"].isin(city)]
elif region and state:
    filtered_df = df3[df["Region"].isin(region) & df3["State"].isin(state)]
elif city:
    filtered_df = df3[df3["City"].isin(city)]
else:
    filtered_df = df3[df3["Region"].isin(region) & df3["State"].isin(state) & df3["City"].isin(city)]

#groupby operation on a DataFrame filtered_df
#It groups the data by the "Category" column and calculates the sum of the "Sales" column for each category
category_df = filtered_df.groupby(by = ["Category"], as_index = False)["Sales"].sum()

#Using Plotly Express to create a bar chart, showing category-wise sales with text labels for the sales amounts
with col1:
    st.subheader("Category wise Sales")
    fig = px.bar(category_df, x = "Category", y = "Sales", text = ['${:,.2f}'.format(x) for x in category_df["Sales"]],
                 template = "seaborn")
    st.plotly_chart(fig,use_container_width=True, height = 200)

#Using Plotly Express to create a pie chart, showing region-wise sales with labels outside the pie slices
with col2:
    st.subheader("Region wise Sales")
    fig = px.pie(filtered_df, values = "Sales", names = "Region", hole = 0.5)
    fig.update_traces(text = filtered_df["Region"], textposition = "outside")
    st.plotly_chart(fig,use_container_width=True)

#Creating two columns 
cl1, cl2 = st.columns((2))

#Display expander widget with the label "Category_ViewData"
#When expanded, it shows the sales for each category; styled category_df DataFrame with a background gradient
with cl1:
    with st.expander("Category_ViewData"):
        st.write(category_df.style.background_gradient(cmap="Blues"))
        csv = category_df.to_csv(index = False).encode('utf-8')
        st.download_button("Download Data", data = csv, file_name = "Category.csv", mime = "text/csv",
                            help = 'Click here to download the data as a CSV file')
        
#Display expander widget with the label "Region_ViewData"
#When expanded, it shows the sales from each region; styled category_df DataFrame with a background gradient
with cl2:
    with st.expander("Region_ViewData"):
        region = filtered_df.groupby(by = "Region", as_index = False)["Sales"].sum()
        st.write(region.style.background_gradient(cmap="Oranges"))
        csv = region.to_csv(index = False).encode('utf-8')
        st.download_button("Download Data", data = csv, file_name = "Region.csv", mime = "text/csv",
                        help = 'Click here to download the data as a CSV file')

#Adds a new column named "month_year" to the DataFrame filtered_df
#This new column contains the month and year information extracted from the "Order Date" column
filtered_df["month_year"] = filtered_df["Order Date"].dt.to_period("M")

#Display a line chart showing the sales trends over time
#The x-axis shows the month-year periods and the y-axis shows the sales amounts
st.subheader('Time Series Analysis')
linechart = pd.DataFrame(filtered_df.groupby(filtered_df["month_year"].dt.strftime("%Y : %b"))["Sales"].sum()).reset_index()
fig2 = px.line(linechart, x = "month_year", y="Sales", labels = {"Sales": "Amount"},height=500, width = 1000,template="gridon")
st.plotly_chart(fig2,use_container_width=True)

#Display sales for each month_year 
with st.expander("View Data of TimeSeries:"):
    st.write(linechart.T.style.background_gradient(cmap="Blues"))
    csv = linechart.to_csv(index=False).encode("utf-8")
    st.download_button('Download Data', data = csv, file_name = "TimeSeries.csv", mime ='text/csv')

#Display treemap chart showing hierarchical data with regions, categories, and sub-categories
#Size of each segment represents sales, and the color is based on sub-categories
st.subheader("Hierarchical view of Sales using TreeMap")
fig3 = px.treemap(filtered_df, path = ["Region","Category","Sub-Category"], values = "Sales",hover_data = ["Sales"],
                  color = "Sub-Category")
fig3.update_layout(width = 800, height = 650)
st.plotly_chart(fig3, use_container_width=True)

#Create two columns 
chart1, chart2 = st.columns((2))

#Display a pie chart showing segment-wise sales data
#Each slice represents a segment and the segment labels are displayed inside the slices
with chart1:
    st.subheader('Segment wise Sales')
    fig = px.pie(filtered_df, values = "Sales", names = "Segment", template = "plotly_dark")
    fig.update_traces(text = filtered_df["Segment"], textposition = "inside")
    st.plotly_chart(fig,use_container_width=True)

#Display a pie chart showing category-wise sales data
#Each slice represents a category and the category labels are displayed inside the slices
with chart2:
    st.subheader('Category wise Sales')
    fig = px.pie(filtered_df, values = "Sales", names = "Category", template = "gridon")
    fig.update_traces(text = filtered_df["Category"], textposition = "inside")
    st.plotly_chart(fig,use_container_width=True)

import plotly.figure_factory as ff
#Display the summary table (df_sample) and the month-wise sub-category table (sub_category_Year)
st.subheader(":point_right: Month wise Sub-Category Sales Summary")
with st.expander("Summary_Table"):
    df_sample = df[0:5][["Region","State","City","Category","Sales","Profit","Quantity"]]
    fig = ff.create_table(df_sample, colorscale = "Cividis")
    st.plotly_chart(fig, use_container_width=True)

    st.markdown("Month wise sub-Category Table")
    filtered_df["month"] = filtered_df["Order Date"].dt.month_name()
    sub_category_Year = pd.pivot_table(data = filtered_df, values = "Sales", index = ["Sub-Category"],columns = "month")
    st.write(sub_category_Year.style.background_gradient(cmap="Blues"))

#Display a scatter plot showing the relationship between "Sales" and "Profit," with data points sized based on "Quantity"
data1 = px.scatter(filtered_df, x = "Sales", y = "Profit", size = "Quantity")
data1['layout'].update(title="Relationship between Sales and Profits using Scatter Plot.",
                       titlefont = dict(size=20),xaxis = dict(title="Sales",titlefont=dict(size=19)),
                       yaxis = dict(title = "Profit", titlefont = dict(size=19)))
st.plotly_chart(data1,use_container_width=True)

#Display the selected portion of the filtered_df DataFrame as a table with background gradient styling applied
with st.expander("View Data"):
    st.write(filtered_df.iloc[:500,1:20:2].style.background_gradient(cmap="Oranges"))

#Display the "Download Data" button, and users can click it to download the original DataFrame as a CSV file named "Data.csv." 
csv = df.to_csv(index = False).encode('utf-8')
st.download_button('Download Data', data = csv, file_name = "Data.csv",mime = "text/csv")

